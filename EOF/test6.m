clear all; clc
%% Testing extract_v3 with multiple sets of artificial data generated by 
%% synthesize and calculating the covariance matrix. Results are compared 
%% to the analytical calculation of the covariance matrix.

% Forming column vectors x and t. All t0's < tstart and t1's > tfinal.  
t0_1=0 ; t1_1=10 ; npts1=1000 ; 
parameters1.A=2 ; parameters1.omega=1 ;parameters1.theta=1 ; nanpts1=20 ;
[x1, t1] = synthesize(t0_1, t1_1, npts1, parameters1, nanpts1);

t0_2=1 ; t1_2=12 ; npts2=1200 ; 
parameters2.A=2 ; parameters2.omega=2 ;parameters2.theta=1 ; nanpts2=10 ;
[x2, t2] = synthesize(t0_2, t1_2, npts2, parameters2, nanpts2);

t0_3=0.8 ; t1_3=9.8 ; npts3=1300 ; 
parameters3.A=2 ; parameters3.omega=3 ;parameters3.theta=1 ; nanpts3=18 ;
[x3, t3] = synthesize(t0_3, t1_3, npts3, parameters3, nanpts3);

% Extracting certain segments from x's and t's for calculation of the 
% covariance matrix
tstart=2 ; tfinal=8 ; dt=0.001 ; 

% Inputs below are optional. Comment out line 26-28 and uncomment line 25 
% and 30-35 if inputs below are specified.
% normalize= ; max_nan= ; max_succ_nan= ; interp_meth= ;   
[x_out1, t_out1, x_mean1, norm_fac1] = extract_v3(tstart, tfinal, t1, x1, dt);
[x_out2, t_out2, x_mean2, norm_fac2] = extract_v3(tstart, tfinal, t2, x2, dt);
[x_out3, t_out3, x_mean3, norm_fac3] = extract_v3(tstart, tfinal, t3, x3, dt);

% [x_out1, t_out1, x_mean1, norm_fac1] = extract_v3(tstart, tfinal, t1, x1, dt,...
%     normalize, max_nan, max_succ_nan, interp_meth);
% [x_out2, t_out2, x_mean2, norm_fac2] = extract_v3(tstart, tfinal, t2, x2, dt,...
%     normalize, max_nan, max_succ_nan, interp_meth);
% [x_out3, t_out3, x_mean3, norm_fac3] = extract_v3(tstart, tfinal, t3, x3, dt,...
%     normalize, max_nan, max_succ_nan, interp_meth);

% Using cov_v2 to get the covariance matrix
x_mat = [x_out1.'; x_out2.'; x_out3.'];
cov_num = cov_v2(x_mat, t_out1);

% Calculating the covariance matrix analytically
A = [parameters1.A; parameters2.A; parameters3.A];
omega = [parameters1.omega; parameters2.omega; parameters3.omega];
theta = [parameters1.theta; parameters2.theta; parameters3.theta];

m = length(A);
n = (tfinal-tstart)/dt+1;
A_mat1 = repmat(A,1,m); 
A_mat2 = A_mat1.';
omega_mat1 = repmat(omega,1,m); 
omega_mat2 = omega_mat1.';
theta_mat1 = repmat(theta,1,m); 
theta_mat2 = theta_mat1.';

% cor_mat is a matrix of logicals that is used to determine when to 
% calculate using the formula when both omega values are equal  
cor_mat = omega_mat1==omega_mat2;

% intermediate matrix that changes the diagonals from NaN to zeros
cov_int = (~cor_mat).*(((sin((omega_mat1+omega_mat2)*tfinal+(theta_mat1+...
    theta_mat2)))./(omega_mat1+omega_mat2) + (sin((omega_mat1-...
    omega_mat2)*tfinal+(theta_mat1-theta_mat2)))./(omega_mat1-omega_mat2))...
    - ((sin((omega_mat1+omega_mat2)*tstart+(theta_mat1+...
    theta_mat2)))./(omega_mat1+omega_mat2) + (sin((omega_mat1-...
    omega_mat2)*tstart+(theta_mat1-theta_mat2)))./(omega_mat1-omega_mat2)));

cov_int(isnan(cov_int))=0;

cov_exact = (A_mat1.*A_mat2/2/(tfinal-tstart)).*(cov_int+...
    (cor_mat.*(((sin(2*omega_mat1*tfinal+theta_mat1+theta_mat2))./(2*omega_mat1)...
    +tfinal*cos(theta_mat1-theta_mat2)) - ((sin(2*omega_mat1*tstart +...
    theta_mat1+theta_mat2))./(2*omega_mat1)+tstart*cos(theta_mat1-theta_mat2)))));

% Calculating fractional error
frac_error = abs((cov_num-cov_exact)./cov_exact)